/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import fs from "node:fs/promises";
import path from "node:path";

import { Flags } from "@oclif/core";
import type { ExportSpecifierStructure } from "ts-morph";
import { ModuleKind, Project, ScriptKind } from "ts-morph";

import { BaseCommand } from "../../base.js";
// eslint-disable-next-line import/no-internal-modules
import { ApiLevel } from "../../library/apiLevel.js";
// eslint-disable-next-line import/no-internal-modules
import { getApiExports } from "../../library/typescriptApi.js";
import type { CommandLogger } from "../../logging.js";

/**
 * Generates type declarations files for Fluid Framework APIs to support API levels (/alpha, /beta. etc.).
 */
export default class GenerateEntrypointsCommand extends BaseCommand<
	typeof GenerateEntrypointsCommand
> {
	static readonly description =
		`Generates type declaration entrypoints for Fluid Framework API levels (/alpha, /beta. etc.)`;

	static readonly flags = {
		mainEntrypoint: Flags.file({
			description: "Main entrypoint file containing all untrimmed exports.",
			default: "./src/index.ts",
			exists: true,
		}),
		outDir: Flags.directory({
			description: "Directory to emit entrypoint declaration files.",
			default: "./lib",
			exists: true,
		}),
		...BaseCommand.flags,
	};

	public async run(): Promise<void> {
		const { mainEntrypoint, outDir } = this.flags;

		const packageJson = await fs.readFile("./package.json", { encoding: "utf8" });
		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
		const packageName = JSON.parse(packageJson).name;
		if (typeof packageName !== "string") {
			this.errorLog(`unable to read package name`);
			return;
		}

		const unscopedPackageName = /[^/]+$/.exec(packageName)?.[0];
		if (unscopedPackageName === undefined) {
			this.errorLog(`unable to parse package name`);
			return;
		}
		return generateEntrypoints(
			mainEntrypoint,
			path.join(outDir, unscopedPackageName),
			this.logger,
		);
	}
}

const generatedHeader: string = `/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by "flub generate api" in @fluidframework/build-tools.
 */
`;

async function generateEntrypoints(
	mainEntrypoint: string,
	baseOutPath: string,
	log: CommandLogger,
): Promise<void> {
	/**
	 * List of source file save promises. Used to collect modified source file save promises so we can await them all at
	 * once.
	 */
	const fileSavePromises: Promise<void>[] = [];

	log.info(`Processing: ${mainEntrypoint}`);

	// Iterate over each source file, looking for Fluid imports
	const project = new Project({
		skipAddingFilesFromTsConfig: true,
		compilerOptions: { module: ModuleKind.Node16 },
	});
	const mainSourceFile = project.addSourceFileAtPath(mainEntrypoint);
	const exports = getApiExports(mainSourceFile);

	if (exports.unknown.length > 0) {
		log.errorLog(
			`${
				exports.unknown.length
			} export(s) found without a recognized API level:\n\t${exports.unknown.map(
				({ name, decl }) =>
					`${decl.getSourceFile().getFilePath()}:${decl.getStartLineNumber()}: ${name}`,
			)}`,
		);
	}

	// This order is critical as public should include beta should include alpha.
	const apiLevels: readonly Exclude<ApiLevel, typeof ApiLevel.internal>[] = [
		ApiLevel.public,
		ApiLevel.beta,
		ApiLevel.alpha,
	] as const;
	const namedExports: Omit<ExportSpecifierStructure, "kind">[] = [];
	for (const apiLevel of apiLevels) {
		// Append this levels additional (or only) exports sorted by ascending case-sensitive name
		const orgLength = namedExports.length;
		const levelExports = [...exports[apiLevel]].sort((a, b) => (a.name > b.name ? 1 : -1));
		namedExports.push(...levelExports);
		if (namedExports.length > orgLength) {
			namedExports[orgLength].leadingTrivia = `\n// ${apiLevel} APIs`;
			namedExports[namedExports.length - 1].trailingTrivia = "\n";
		}

		const outFile = `${baseOutPath}-${apiLevel}.d.ts`;
		log.info(`\tGenerating ${outFile}`);
		const sourceFile = project.createSourceFile(outFile, undefined, {
			overwrite: true,
			scriptKind: ScriptKind.TS,
		});

		sourceFile.insertText(0, generatedHeader);
		sourceFile.addExportDeclaration({
			moduleSpecifier: `./${mainSourceFile
				.getBaseName()
				.replace(/\.(?:d\.)?([cm]?)ts$/, ".$1js")}`,
			namedExports,
		});

		fileSavePromises.push(sourceFile.save());
	}

	await Promise.all(fileSavePromises);
}
