## API Report File for "@fluidframework/datastore-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AttachState } from '@fluidframework/container-definitions';
import type { FluidObject } from '@fluidframework/core-interfaces';
import type { IAudience } from '@fluidframework/container-definitions';
import type { IDeltaManager } from '@fluidframework/container-definitions';
import type { IDisposable } from '@fluidframework/core-interfaces';
import type { IDocumentMessage } from '@fluidframework/protocol-definitions';
import type { IEvent } from '@fluidframework/core-interfaces';
import type { IEventProvider } from '@fluidframework/core-interfaces';
import type { IExperimentalIncrementalSummaryContext } from '@fluidframework/runtime-definitions';
import type { IFluidHandle } from '@fluidframework/core-interfaces';
import type { IFluidHandleContext } from '@fluidframework/core-interfaces';
import type { IFluidLoadable } from '@fluidframework/core-interfaces';
import type { IGarbageCollectionData } from '@fluidframework/runtime-definitions';
import type { IIdCompressor } from '@fluidframework/id-compressor';
import type { IInboundSignalMessage } from '@fluidframework/runtime-definitions';
import type { IQuorumClients } from '@fluidframework/protocol-definitions';
import type { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import type { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import type { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import type { ITelemetryContext } from '@fluidframework/runtime-definitions';

// @beta
type FlattenIntersection<T> = T extends Record<any, any> ? {
    [K in keyof T]: T[K];
} : T;

// @public (undocumented)
export interface IChannel extends IFluidLoadable {
    // (undocumented)
    readonly attributes: IChannelAttributes;
    connect(services: IChannelServices): void;
    getAttachSummary(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    getGCData(fullGC?: boolean): IGarbageCollectionData;
    readonly id: string;
    isAttached(): boolean;
    summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext, incrementalSummaryContext?: IExperimentalIncrementalSummaryContext): Promise<ISummaryTreeWithStats>;
}

// @public
export interface IChannelAttributes {
    readonly packageVersion?: string;
    readonly snapshotFormatVersion: string;
    readonly type: string;
}

// @public
export interface IChannelFactory<out TChannel = unknown> {
    readonly attributes: IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string): TChannel & IChannel;
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<TChannel & IChannel>;
    readonly type: string;
}

// @public
export interface IChannelServices {
    // (undocumented)
    deltaConnection: IDeltaConnection;
    // (undocumented)
    objectStorage: IChannelStorageService;
}

// @public
export interface IChannelStorageService {
    contains(path: string): Promise<boolean>;
    list(path: string): Promise<string[]>;
    readBlob(path: string): Promise<ArrayBufferLike>;
}

// @public
export interface IDeltaConnection {
    // @deprecated (undocumented)
    addedGCOutboundReference?(srcHandle: IFluidHandle, outboundHandle: IFluidHandle): void;
    attach(handler: IDeltaHandler): void;
    // (undocumented)
    connected: boolean;
    dirty(): void;
    submit(messageContent: any, localOpMetadata: unknown): void;
}

// @public
export interface IDeltaHandler {
    applyStashedOp(message: any): void;
    process: (message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown) => void;
    reSubmit(message: any, localOpMetadata: unknown): void;
    rollback?(message: any, localOpMetadata: unknown): void;
    setConnectionState(connected: boolean): void;
}

// @public
export interface IFluidDataStoreRuntime extends IEventProvider<IFluidDataStoreRuntimeEvents>, IDisposable {
    addChannel(channel: IChannel): void;
    readonly attachState: AttachState;
    bindChannel(channel: IChannel): void;
    // (undocumented)
    readonly channelsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    createChannel(id: string | undefined, type: string): IChannel;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    readonly entryPoint: IFluidHandle<FluidObject>;
    getAudience(): IAudience;
    getChannel(id: string): Promise<IChannel>;
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly idCompressor?: IIdCompressor;
    // (undocumented)
    readonly IFluidHandleContext: IFluidHandleContext;
    // (undocumented)
    readonly logger: ITelemetryBaseLogger;
    // (undocumented)
    readonly objectsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly options: Record<string | number, any>;
    // (undocumented)
    readonly rootRoutingContext: IFluidHandleContext;
    submitSignal: (type: string, content: unknown, targetClientId?: string) => void;
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandle<ArrayBufferLike>>;
    waitAttached(): Promise<void>;
}

// @public
export interface IFluidDataStoreRuntimeEvents extends IEvent {
    // (undocumented)
    (event: "disconnected" | "dispose" | "attaching" | "attached", listener: () => void): any;
    // (undocumented)
    (event: "op", listener: (message: ISequencedDocumentMessage) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: IInboundSignalMessage, local: boolean) => void): any;
    // (undocumented)
    (event: "connected", listener: (clientId: string) => void): any;
}

// @alpha
export type Internal_JsonableForArrayItem<T, TReplaced, TParent> = boolean extends (T extends never ? true : false) ? JsonableTypeWith<TReplaced> : unknown extends T ? JsonableTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : undefined extends T ? "error-array-or-tuple-may-not-allow-undefined-value-consider-null" : (<G>() => G extends T ? 1 : 2) extends <G>() => G extends TParent ? 1 : 2 ? TParent : Jsonable<T, TReplaced>;

declare namespace InternalUtilityTypes {
    export {
        NonSymbolWithOptionalPropertyOf,
        NonSymbolWithRequiredPropertyOf,
        IsEnumLike,
        IsExactlyObject,
        FlattenIntersection
    }
}
export { InternalUtilityTypes }

// @beta
type IsEnumLike<T extends object> = T extends readonly (infer _)[] ? false : T extends {
    readonly [i: number]: string;
    readonly [p: string]: number | string;
} ? true extends {
    [K in keyof T]: T[K] extends never ? true : never;
}[keyof T] ? false : true : false;

// @beta
type IsExactlyObject<T extends object> = object extends Required<T> ? false extends T ? false : true : false;

// @alpha
export type Jsonable<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonableTypeWith<TReplaced> : unknown extends T ? JsonableTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends readonly (infer _)[] ? {
    [K in keyof T]: Internal_JsonableForArrayItem<T[K], TReplaced, T>;
} : IsExactlyObject<T> extends true ? JsonableTypeWith<TReplaced> : IsEnumLike<T> extends true ? T : FlattenIntersection<{
    [K in NonSymbolWithRequiredPropertyOf<T>]-?: undefined extends T[K] ? "error-required-property-may-not-allow-undefined-value" : Jsonable<T[K], TReplaced>;
} & {
    [K in NonSymbolWithOptionalPropertyOf<T>]?: Jsonable<T[K], TReplaced | undefined>;
} & {
    [K in keyof T & symbol]: never;
}> : never : never;

// @alpha
export type JsonableTypeWith<T> = null | boolean | number | string | T | {
    [key: string | number]: JsonableTypeWith<T>;
} | JsonableTypeWith<T>[];

// @beta
type NonSymbolWithOptionalPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? never : K;
}[keyof T], undefined | symbol>;

// @beta
type NonSymbolWithRequiredPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? K : never;
}[keyof T], undefined | symbol>;

// @alpha
export type Serializable<T> = Jsonable<T, IFluidHandle>;

```
