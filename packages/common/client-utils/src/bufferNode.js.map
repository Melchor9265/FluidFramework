{"version":3,"file":"bufferNode.js","sourceRoot":"","sources":["bufferNode.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AA0BH;;GAEG;AACU,QAAA,SAAS,GAAG,MAAM,CAAC;AAOhC;;;;;;;;;GASG;AACH,SAAgB,kBAAkB,CACjC,GAAe;AACf,8GAA8G;AAC9G,QAAsC;IAEtC,2EAA2E;IAC3E,6EAA6E;IAC7E,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC3E,CAAC;AARD,gDAQC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,KAAa,EAAE,QAAgB;IAC7D,MAAM,GAAG,GAAG,iBAAS,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC5C,0EAA0E;IAC1E,2EAA2E;IAC3E,uDAAuD;IACvD,OAAO,GAAG,CAAC,UAAU,KAAK,GAAG,CAAC,MAAM,CAAC,UAAU;QAC9C,CAAC,CAAC,GAAG,CAAC,MAAM;QACZ,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;AACtE,CAAC;AARD,wCAQC;AAED;;;;;;;;GAQG;AACI,MAAM,cAAc,GAAG,CAC7B,IAAqB;AACrB,8GAA8G;AAC9G,QAAqC,EAC5B,EAAE,CAAC,iBAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAJxC,QAAA,cAAc,kBAI0B","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Declare the subset of Buffer functionality we want to make available instead of\n * exposing the entirely of Node's typings.  This should match the public interface\n * of the browser implementation, so any changes made in one should be made in both.\n *\n * @internal\n */\nexport declare class Buffer extends Uint8Array {\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case -- this value is supported, just discouraged\n\ttoString(encoding?: \"utf8\" | \"utf-8\" | \"base64\"): string;\n\n\t/**\n\t * Static constructor\n\t *\n\t * @param value - (string | ArrayBuffer).\n\t * @param encodingOrOffset - (string | number).\n\t * @param length - (number).\n\t *\n\t * @privateRemarks TODO: Use actual types\n\t */\n\tstatic from(value: unknown, encodingOrOffset?: unknown, length?: unknown): IsoBuffer;\n\tstatic isBuffer(obj: unknown): obj is Buffer;\n}\n\n/**\n * @internal\n */\nexport const IsoBuffer = Buffer;\n\n/**\n * @internal\n */\nexport type IsoBuffer = Buffer;\n\n/**\n * Converts a Uint8Array to a string of the provided encoding.\n * @remarks Useful when the array might be an IsoBuffer.\n * @param arr - The array to convert.\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default.\n * @returns The converted string.\n *\n * @internal\n */\nexport function Uint8ArrayToString(\n\tarr: Uint8Array,\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case -- this value is supported, just discouraged\n\tencoding?: \"utf8\" | \"utf-8\" | \"base64\",\n): string {\n\t// Buffer extends Uint8Array.  Therefore, 'arr' may already be a Buffer, in\n\t// which case we can avoid copying the Uint8Array into a new Buffer instance.\n\treturn (Buffer.isBuffer(arr) ? arr : Buffer.from(arr)).toString(encoding);\n}\n\n/**\n * Convert base64 or utf8 string to array buffer.\n * @param encoding - The input string's encoding.\n *\n * @internal\n */\nexport function stringToBuffer(input: string, encoding: string): ArrayBufferLike {\n\tconst iso = IsoBuffer.from(input, encoding);\n\t// In a Node environment, IsoBuffer may be a Node.js Buffer.  Node.js will\n\t// pool multiple small Buffer instances into a single ArrayBuffer, in which\n\t// case we need to slice the appropriate span of bytes.\n\treturn iso.byteLength === iso.buffer.byteLength\n\t\t? iso.buffer\n\t\t: iso.buffer.slice(iso.byteOffset, iso.byteOffset + iso.byteLength);\n}\n\n/**\n * Convert binary blob to string format\n *\n * @param blob - The binary blob\n * @param encoding - Output string's encoding\n * @returns The blob in string format\n *\n * @alpha\n */\nexport const bufferToString = (\n\tblob: ArrayBufferLike,\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case -- this value is supported, just discouraged\n\tencoding: \"utf8\" | \"utf-8\" | \"base64\",\n): string => IsoBuffer.from(blob).toString(encoding);\n"]}