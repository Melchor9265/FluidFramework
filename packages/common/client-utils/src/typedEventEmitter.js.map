{"version":3,"file":"typedEventEmitter.js","sourceRoot":"","sources":["typedEventEmitter.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAEH,8EAA8E;AAC9E,wDAAwD;AACxD,mCAAsC;AAwCtC;;;GAGG;AACH,MAAa,iBACZ,SAAQ,qBAAY;IAGpB;QACC,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAsC,CAAC;QACrF,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAsC,CAAC;QACnE,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAsC,CAAC;QACvE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAGrD,CAAC;QACF,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAG7D,CAAC;QACF,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAsC,CAAC;QAC3F,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAsC,CAAC;IACtE,CAAC;CAQD;AA3BD,8CA2BC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// False positive: this is an import from the `events` package, not from Node.\n// eslint-disable-next-line unicorn/prefer-node-protocol\nimport { EventEmitter } from \"events\";\nimport {\n\tIEvent,\n\tTransformedEvent,\n\tIEventTransformer,\n\tIEventProvider,\n} from \"@fluidframework/core-interfaces\";\n\n/**\n * The event emitter polyfill and the node event emitter have different event types:\n * string | symbol vs. string | number\n *\n * This type allow us to correctly handle either type\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EventEmitterEventType = EventEmitter extends { on(event: infer E, listener: any) }\n\t? E\n\t: never;\n\n/**\n * @public\n */\nexport type TypedEventTransform<TThis, TEvent> =\n\t// Event emitter supports some special events for the emitter itself to use\n\t// this exposes those events for the TypedEventEmitter.\n\t// Since we know what the shape of these events are, we can describe them directly via a TransformedEvent\n\t// which easier than trying to extend TEvent directly\n\tTransformedEvent<\n\t\tTThis,\n\t\t\"newListener\" | \"removeListener\",\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tParameters<(event: string, listener: (...args: any[]) => void) => void>\n\t> &\n\t\t// Expose all the events provides by TEvent\n\t\tIEventTransformer<TThis, TEvent & IEvent> &\n\t\t// Add the default overload so this is covertable to EventEmitter regardless of environment\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tTransformedEvent<TThis, EventEmitterEventType, any[]>;\n\n/**\n * Event Emitter helper class the supports emitting typed events\n * @public\n */\nexport class TypedEventEmitter<TEvent>\n\textends EventEmitter\n\timplements IEventProvider<TEvent & IEvent>\n{\n\tconstructor() {\n\t\tsuper();\n\t\tthis.addListener = super.addListener.bind(this) as TypedEventTransform<this, TEvent>;\n\t\tthis.on = super.on.bind(this) as TypedEventTransform<this, TEvent>;\n\t\tthis.once = super.once.bind(this) as TypedEventTransform<this, TEvent>;\n\t\tthis.prependListener = super.prependListener.bind(this) as TypedEventTransform<\n\t\t\tthis,\n\t\t\tTEvent\n\t\t>;\n\t\tthis.prependOnceListener = super.prependOnceListener.bind(this) as TypedEventTransform<\n\t\t\tthis,\n\t\t\tTEvent\n\t\t>;\n\t\tthis.removeListener = super.removeListener.bind(this) as TypedEventTransform<this, TEvent>;\n\t\tthis.off = super.off.bind(this) as TypedEventTransform<this, TEvent>;\n\t}\n\treadonly addListener: TypedEventTransform<this, TEvent>;\n\treadonly on: TypedEventTransform<this, TEvent>;\n\treadonly once: TypedEventTransform<this, TEvent>;\n\treadonly prependListener: TypedEventTransform<this, TEvent>;\n\treadonly prependOnceListener: TypedEventTransform<this, TEvent>;\n\treadonly removeListener: TypedEventTransform<this, TEvent>;\n\treadonly off: TypedEventTransform<this, TEvent>;\n}\n"]}